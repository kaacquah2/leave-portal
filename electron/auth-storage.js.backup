/**
 * Secure token storage for Electron
 * Uses Electron's safeStorage API when available (macOS Keychain, Windows Credential Manager, Linux Secret Service)
 * Falls back to encrypted file storage if safeStorage is not available
 */

const { safeStorage } = require('electron');
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { app } = require('electron');

const TOKEN_FILE = path.join(app.getPath('userData'), 'token.encrypted');
const TOKEN_META_FILE = path.join(app.getPath('userData'), 'token.meta.json');

// Encryption key derived from app name (for fallback storage)
// Uses PBKDF2 for better key derivation security
function getEncryptionKey() {
  const appName = app.getName();
  const userDataPath = app.getPath('userData');
  const salt = crypto.createHash('sha256').update(appName + userDataPath).digest();
  
  // Use PBKDF2 for key derivation (more secure than simple hash)
  // 100,000 iterations is a good balance between security and performance
  return crypto.pbkdf2Sync(appName + userDataPath, salt, 100000, 32, 'sha256');
}

/**
 * Check if secure storage is available
 */
function isSecureStorageAvailable() {
  try {
    return safeStorage.isEncryptionAvailable();
  } catch (error) {
    console.error('[Auth Storage] Error checking secure storage:', error);
    return false;
  }
}

/**
 * Get stored authentication token
 */
function getToken() {
  try {
    if (!fs.existsSync(TOKEN_FILE)) {
      return null;
    }
    
    // Check metadata to see which encryption method was used
    let useSafeStorage = false;
    if (fs.existsSync(TOKEN_META_FILE)) {
      try {
        const meta = JSON.parse(fs.readFileSync(TOKEN_META_FILE, 'utf8'));
        useSafeStorage = meta.useSafeStorage === true;
      } catch (error) {
        console.warn('[Auth Storage] Error reading metadata, using fallback:', error);
      }
    }
    
    // Try safeStorage decryption first
    if (useSafeStorage && isSecureStorageAvailable()) {
      try {
        const encrypted = fs.readFileSync(TOKEN_FILE);
        const decrypted = safeStorage.decryptString(Buffer.from(encrypted, 'base64'));
        return decrypted;
      } catch (error) {
        console.warn('[Auth Storage] safeStorage decryption failed, trying fallback:', error);
      }
    }
    
    // Fallback: Decrypt using Node.js crypto
    // Format: IV (16 bytes hex) + encrypted data
    const encryptedData = fs.readFileSync(TOKEN_FILE, 'utf8');
    if (encryptedData.length < 32) {
      throw new Error('Invalid encrypted data format');
    }
    const iv = Buffer.from(encryptedData.substring(0, 32), 'hex');
    if (iv.length !== 16) {
      throw new Error('Invalid IV length');
    }
    const encrypted = encryptedData.substring(32);
    const key = getEncryptionKey();
    const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv);
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
  } catch (error) {
    console.error('[Auth Storage] Error getting token:', error);
    return null;
  }
}

/**
 * Store authentication token securely
 */
function setToken(token) {
  try {
    // Ensure userData directory exists
    const userDataDir = app.getPath('userData');
    if (!fs.existsSync(userDataDir)) {
      fs.mkdirSync(userDataDir, { recursive: true });
    }
    
    // Use safeStorage encryption if available
    if (isSecureStorageAvailable()) {
      try {
        // Encrypt token using safeStorage
        const encrypted = safeStorage.encryptString(token);
        // Store encrypted token in file (safeStorage returns Buffer)
        fs.writeFileSync(TOKEN_FILE, encrypted.toString('base64'), { mode: 0o600 });
        // Store metadata
        fs.writeFileSync(TOKEN_META_FILE, JSON.stringify({ useSafeStorage: true }), { mode: 0o600 });
        console.log('[Auth Storage] Token stored using safeStorage');
        return;
      } catch (error) {
        console.warn('[Auth Storage] safeStorage encryption failed, using fallback:', error);
      }
    }
    
    // Fallback: Encrypt using Node.js crypto
    // Generate random IV for each encryption (cryptographically secure)
    const iv = crypto.randomBytes(16);
    const key = getEncryptionKey();
    const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);
    let encrypted = cipher.update(token, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    // Store IV + encrypted data (IV is 16 bytes = 32 hex chars)
    fs.writeFileSync(TOKEN_FILE, iv.toString('hex') + encrypted, { mode: 0o600 });
    // Store metadata
    fs.writeFileSync(TOKEN_META_FILE, JSON.stringify({ useSafeStorage: false }), { mode: 0o600 });
    console.log('[Auth Storage] Token stored using fallback encryption');
  } catch (error) {
    console.error('[Auth Storage] Error storing token:', error);
    throw error;
  }
}

/**
 * Clear stored authentication token
 */
function clearToken() {
  try {
    if (fs.existsSync(TOKEN_FILE)) {
      fs.unlinkSync(TOKEN_FILE);
    }
    if (fs.existsSync(TOKEN_META_FILE)) {
      fs.unlinkSync(TOKEN_META_FILE);
    }
    console.log('[Auth Storage] Token cleared');
  } catch (error) {
    console.error('[Auth Storage] Error clearing token:', error);
  }
}

/**
 * Check if token exists
 */
function hasToken() {
  return fs.existsSync(TOKEN_FILE);
}

module.exports = {
  getToken,
  setToken,
  clearToken,
  hasToken,
  isSecureStorageAvailable,
};

